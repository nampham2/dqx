# SQL Formatting Implementation Plan v1

## Overview
This plan implements mandatory SQL formatting throughout DQX using the `sqlparse` library. All SQL generated by the framework will be automatically formatted for consistency and readability.

## Goals
1. Add mandatory SQL formatting to all SQL generation points
2. Use `sqlparse` library for consistent formatting
3. Ensure all tests pass with formatted SQL
4. Maintain 100% test coverage

## Implementation Tasks

### Task Group 1: Foundation Setup
**Goal**: Add sqlparse dependency and create formatting utility

1. **Add sqlparse to dependencies**
   - File: `pyproject.toml`
   - Add `"sqlparse>=0.5.0",` to the dependencies list
   - Run `uv sync` to install the new dependency

2. **Create SQL formatter module**
   - Create new file: `src/dqx/sql_formatter.py`
   - Implementation:
   ```python
   """SQL formatting utilities for DQX.

   This module provides consistent SQL formatting across the framework
   using sqlparse library.
   """

   import sqlparse


   def format_sql(sql: str) -> str:
       """Format SQL query with consistent DQX style.

       Applies mandatory formatting rules:
       - Keywords in uppercase (SELECT, FROM, WHERE)
       - Identifiers in lowercase
       - 2-space indentation (compact for console output)
       - Proper line breaks and alignment

       Args:
           sql: Raw SQL string to format

       Returns:
           Formatted SQL string

       Example:
           >>> raw = "select count(*) from table where x > 0"
           >>> format_sql(raw)
           'SELECT COUNT(*)\nFROM table\nWHERE x > 0'
       """
       # Remove extra whitespace first
       sql = " ".join(sql.split())

       # Apply sqlparse formatting
       formatted = sqlparse.format(
           sql,
           keyword_case='upper',      # SELECT, FROM, WHERE, etc.
           identifier_case='lower',   # table and column names
           strip_comments=False,      # Preserve comments
           reindent=True,            # Enable indentation
           indent_width=2,           # 2-space indent (compact for console)
           wrap_after=120,           # Line wrapping at 120 chars
           output_format='sql',      # Standard SQL output
           comma_first=False,        # Commas at end of line
       )

       return formatted.strip()
   ```

3. **Commit the dependency**
   ```bash
   git add pyproject.toml uv.lock
   git commit -m "build: add sqlparse dependency for SQL formatting"
   ```

4. **Create SQL formatter module**
   - Continue with creating `src/dqx/sql_formatter.py` as specified above

5. **Add formatter tests**
   - Create new file: `tests/test_sql_formatter.py`
   - Test cases:
     - Basic SELECT formatting
     - CTE formatting
     - Multi-line queries
     - Queries with aliases
     - Edge cases (empty string, whitespace only)

   Example test structure:
   ```python
   import pytest
   from dqx.sql_formatter import format_sql


   def test_format_simple_select():
       raw = "select * from table"
       expected = "SELECT *\nFROM table"
       assert format_sql(raw) == expected


   def test_format_cte():
       raw = "with source as (select * from t) select count(*) from source"
       result = format_sql(raw)
       assert "WITH source AS" in result
       assert "SELECT COUNT(*)" in result
   ```

6. **Run tests and commit**
   ```bash
   uv run pytest tests/test_sql_formatter.py -v
   git add src/dqx/sql_formatter.py tests/test_sql_formatter.py
   git commit -m "feat: add SQL formatter utility module and tests"
   ```

### Task Group 2: Update Core SQL Generation
**Goal**: Apply formatting to main SQL generation functions

1. **Update dialect.py build_cte_query**
   - File: `src/dqx/dialect.py`
   - Import the formatter at top: `from dqx.sql_formatter import format_sql`
   - Modify `build_cte_query` function:
   ```python
   def build_cte_query(cte_sql: str, select_expressions: list[str]) -> str:
       """Build CTE query with mandatory formatting."""
       if not select_expressions:
           raise ValueError("No SELECT expressions provided")

       # Build the query without manual formatting
       select_clause = ", ".join(select_expressions)
       raw_query = f"WITH source AS ({cte_sql}) SELECT {select_clause} FROM source"

       # Apply mandatory formatting
       return format_sql(raw_query)
   ```

2. **Update DuckDBDialect.build_cte_query**
   - File: `src/dqx/dialect.py`
   - The method already delegates to `build_cte_query`, so no changes needed

3. **Update tests for dialect**
   - File: `tests/test_dialect.py`
   - Update expected SQL strings to match formatted output
   - Example:
   ```python
   # Old expectation
   assert "WITH source AS" in result

   # New expectation (check formatted structure)
   assert result.startswith("WITH source AS")
   assert "SELECT" in result
   assert result.count("\n") >= 3  # Proper line breaks
   ```

4. **Run tests and commit**
   ```bash
   uv run pytest tests/test_dialect.py -v
   git add src/dqx/dialect.py tests/test_dialect.py
   git commit -m "feat: apply SQL formatting to dialect build_cte_query"
   ```

### Task Group 3: Update Data Source Extensions
**Goal**: Apply formatting to data source CTE methods

1. **Update DuckRelationDataSource**
   - File: `src/dqx/extensions/duck_ds.py`
   - Import formatter: `from dqx.sql_formatter import format_sql`
   - Update `cte` method:
   ```python
   def cte(self, nominal_date: datetime.date) -> str:
       """Get the formatted CTE for this data source."""
       raw_sql = f"SELECT * FROM {self._table_name}"
       return format_sql(raw_sql)
   ```

2. **Update ArrowDataSource**
   - File: `src/dqx/extensions/pyarrow_ds.py`
   - Import formatter: `from dqx.sql_formatter import format_sql`
   - Update `cte` method:
   ```python
   def cte(self, nominal_date: datetime.date) -> str:
       """Get the formatted CTE for this data source."""
       raw_sql = f"SELECT * FROM {self._table_name}"
       return format_sql(raw_sql)
   ```

3. **Update extension tests**
   - Files: `tests/extensions/test_duck_ds.py`, `tests/extensions/test_pyarrow_ds.py`
   - Update any tests that check CTE output to expect formatted SQL

4. **Run tests and commit**
   ```bash
   uv run pytest tests/extensions/ -v
   git add src/dqx/extensions/*.py tests/extensions/test_*.py
   git commit -m "feat: apply SQL formatting to data source extensions"
   ```

### Task Group 4: Search and Update Remaining SQL Generation
**Goal**: Find and update any other SQL generation points

1. **Search for SQL generation patterns**
   - Search for patterns like:
     - `"SELECT` (quoted SELECT statements)
     - `f"SELECT` (f-string SELECT)
     - `"""SELECT` (multiline SQL)
     - `.sql(` (SQL method calls)

   Common locations to check:
   - `src/dqx/analyzer.py` - May have SQL building
   - `src/dqx/specs.py` - SQL fragments in to_sql methods
   - Test files - May have hardcoded SQL expectations

2. **Update analyzer if needed**
   - Check if analyzer builds any SQL directly
   - Apply formatting where appropriate
   - Update corresponding tests

3. **Review and update integration tests**
   - Files in `tests/e2e/`
   - Update SQL expectations to formatted versions
   - Ensure end-to-end tests still pass

4. **Run affected tests and commit**
   ```bash
   uv run pytest tests/test_analyzer.py tests/test_specs.py tests/e2e/ -v
   git add -p  # Selectively add only SQL formatting changes
   git commit -m "feat: apply SQL formatting to remaining SQL generation"
   ```

### Task Group 5: Final Validation
**Goal**: Ensure all tests pass and quality standards are met

1. **Run full test suite**
   ```bash
   uv run pytest tests/ -v
   ```
   - Fix any failing tests
   - Ensure 100% coverage maintained

2. **Run type checking**
   ```bash
   uv run mypy src/
   ```
   - Fix any type errors introduced

3. **Run pre-commit hooks**
   ```bash
   ./bin/run-hooks.sh
   ```
   - Fix any linting issues
   - Ensure code style compliance

4. **Create example demonstrating formatted SQL**
   - Create `examples/sql_formatting_demo.py`
   - Show before/after SQL formatting
   - Demonstrate the improved readability

5. **Final commit**
   ```bash
   git add examples/sql_formatting_demo.py
   git add -p  # Add any remaining test fixes
   git commit -m "test: add SQL formatting demo and fix remaining tests"
   ```

## Testing Strategy

### Unit Tests
- Test `format_sql` function with various SQL patterns
- Test error handling (None, empty strings)
- Test preservation of SQL semantics

### Integration Tests
- Verify formatted SQL executes correctly
- Test with real DuckDB queries
- Ensure no performance regression

### End-to-End Tests
- Run existing e2e tests with formatted SQL
- Verify metrics computation unchanged
- Check result formatting in logs

## Rollback Plan
If issues arise:
1. Remove formatter imports
2. Revert to manual formatting in `build_cte_query`
3. Keep sqlparse dependency for future use

## Success Criteria
1. All SQL output is consistently formatted
2. All tests pass (100% coverage maintained)
3. No performance degradation
4. SQL remains valid and executable

## Notes for Implementation
- Start with Task Group 1 to establish foundation
- Task Group 1 requires TWO commits: one for dependency, one for implementation
- Run tests before each commit to ensure green builds
- Each task group should result in a working state
- If a group fails, debug before proceeding
- The manual alignment in current `build_cte_query` will be replaced by sqlparse
- Focus on consistency over perfect formatting
- Use `git add -p` when needed to selectively stage changes
