"""Comprehensive tests for graph module with simplified architecture."""

from datetime import date
from unittest.mock import MagicMock

import pytest
import sympy as sp
from returns.maybe import Nothing, Some
from returns.result import Failure, Success

from dqx import graph
from dqx.api import Context
from dqx.common import DQXError, ResultKey, ResultKeyProvider, SymbolicValidator
from dqx.display import GraphDisplay


# =============================================================================
# Helper Classes
# =============================================================================


class MockKeyProvider(ResultKeyProvider):
    """Mock key provider for testing."""

    def create(self, key: ResultKey) -> ResultKey:
        return key


class MockContext:
    """Mock context for testing."""
    def __init__(self) -> None:
        self.symbol_table = SymbolTable()


def create_test_root(name: str = "Test") -> tuple[Context, graph.RootNode]:
    """Helper to create a test context and root node."""
    ctx = Context(name)
    return ctx, ctx._graph


# =============================================================================
# 1. Core Node Behavior Tests
# =============================================================================


def test_basic_graph_creation() -> None:
    """Test basic graph creation and structure."""
    ctx, root = create_test_root("Test Suite")
    check = graph.CheckNode("check_1")
    root.add_child(check)

    assertion = graph.AssertionNode(actual=sp.Symbol("x"))
    check.add_child(assertion)

    assert root.name == "Test Suite"
    assert len(root.children) == 1
    assert check in root.children
    assert len(check.children) == 1
    assert assertion in check.children


# =============================================================================
# 2. Design Pattern Tests
# =============================================================================


def test_visitor_pattern_implementation() -> None:
    """Test the visitor pattern for graph traversal."""
    # Create a graph structure
    ctx, root = create_test_root("Test Suite")
    check1 = graph.CheckNode("check1")
    check2 = graph.CheckNode("check2")
    root.add_child(check1)
    root.add_child(check2)

    # Add assertions
    assertion1 = graph.AssertionNode(actual=sp.Symbol("x"))
    check1.add_child(assertion1)

    assertion2 = graph.AssertionNode(actual=sp.Symbol("y"))
    check2.add_child(assertion2)

    # Test traversal with filtering
    assertions = list(root.assertions())
    assert len(assertions) == 2
    assert assertion1 in assertions
    assert assertion2 in assertions

    checks = list(root.checks())
    assert len(checks) == 2
    assert check1 in checks
    assert check2 in checks


def test_custom_visitor() -> None:
    """Test custom visitor implementation."""

    class CountingVisitor(graph.NodeVisitor):
        def __init__(self) -> None:
            self.count = 0

        def visit(self, node: graph.BaseNode) -> None:
            self.count += 1
            # Continue traversal for composite nodes
            if isinstance(node, graph.CompositeNode):
                for child in node.children():
                    child.accept(self)

    # Build a graph
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    assertion = graph.AssertionNode(sp.Symbol("x"))

    root.add_child(check)
    check.add_child(assertion)

    # Count nodes
    visitor = CountingVisitor()
    root.accept(visitor)

    # Should count: root + check + assertion = 3
    assert visitor.count == 3


def test_composite_pattern_hierarchy() -> None:
    """Test the composite pattern for node hierarchy."""
    ctx, root = create_test_root("Root")
    check = graph.CheckNode("Check")
    assertion = graph.AssertionNode(sp.Symbol("x"))

    # Test add_child
    root.add_child(check)
    check.add_child(assertion)

    assert len(root.children) == 1
    assert len(check.children) == 1

    # Test remove_child
    check.remove_child(assertion)
    assert len(check.children) == 0

    # Test get_children
    children = root.children()
    assert children == [check]

    # Re-add assertion to check
    check.add_child(assertion)
    assert check.children() == [assertion]


def test_traverse_without_filter() -> None:
    """Test RootNode traverse method without type filter."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    assertion = graph.AssertionNode(sp.Symbol("x"))

    root.add_child(check)
    check.add_child(assertion)

    # Traverse without filter should return all nodes
    all_nodes = list(root.traverse())
    assert len(all_nodes) == 3  # root + check + assertion
    assert root in all_nodes
    assert check in all_nodes
    assert assertion in all_nodes


# =============================================================================
# 3. Node Hierarchy Tests
# =============================================================================


def test_leaf_nodes_cannot_have_children() -> None:
    """Test that leaf nodes (AssertionNode) cannot have children."""
    # AssertionNode
    assertion = graph.AssertionNode(actual=sp.Symbol("x"))
    with pytest.raises(RuntimeError, match="AssertionNode cannot have children"):
        assertion.add_child(MagicMock())


def test_check_node_only_accepts_assertion_children() -> None:
    """Test that CheckNode only accepts AssertionNode children."""
    check = graph.CheckNode(name="test_check")

    # Create assertion node
    assertion = graph.AssertionNode(actual=sp.Symbol("x"))

    # Add assertion as child - should work
    check.add_child(assertion)

    assert len(check.children) == 1
    assert assertion in check.children


def test_root_node_exists_method() -> None:
    """Test the exists method for backward compatibility."""
    ctx, root = create_test_root("Test")
    check1 = graph.CheckNode("check1")
    check2 = graph.CheckNode("check2")

    # Add check1 but not check2
    root.add_child(check1)

    assert root.exists(check1)
    assert not root.exists(check2)


def test_assertion_node_cannot_have_children() -> None:
    """Test that AssertionNode.add_child raises RuntimeError."""
    assertion = graph.AssertionNode(sp.Symbol("x"))

    # Try to add a child - should raise
    try:
        assertion.add_child("anything")
        assert False, "Should have raised RuntimeError"
    except RuntimeError as e:
        assert str(e) == "AssertionNode cannot have children."


# =============================================================================
# 4. State Management Tests
# =============================================================================


def test_assertion_node_symbol_tracking() -> None:
    """Test AssertionNode's symbol tracking through expression."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("test_check")
    root.add_child(check)

    # Create assertions with different symbols
    sym1 = sp.Symbol("x")
    sym2 = sp.Symbol("y")
    
    assertion1 = graph.AssertionNode(actual=sym1)
    assertion2 = graph.AssertionNode(actual=sym2)
    assertion3 = graph.AssertionNode(actual=sym1 + sym2)
    
    check.add_child(assertion1)
    check.add_child(assertion2)
    check.add_child(assertion3)
    
    # Symbols are tracked in the expression
    assert sym1 in assertion1.actual.free_symbols
    assert sym2 in assertion2.actual.free_symbols
    assert sym1 in assertion3.actual.free_symbols
    assert sym2 in assertion3.actual.free_symbols


def test_check_node_name() -> None:
    """Test CheckNode node_name method."""
    # With label
    check1 = graph.CheckNode("check_id", label="Check Label")
    assert check1.node_name() == "Check Label"

    # Without label
    check2 = graph.CheckNode("check_id")
    assert check2.node_name() == "check_id"


def test_check_node_update_status() -> None:
    """Test CheckNode status aggregation."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Initially check should be pending
    assert check._value == Nothing

    # Aggregate with no children - should remain pending
    check._value = graph.aggregate_children_status(check.children)
    assert check._value == Nothing

    # Add successful assertion
    assertion1 = graph.AssertionNode(sp.Symbol("x"))
    assertion1._value = Some(Success(10.0))
    check.add_child(assertion1)

    # Aggregate status - should be Nothing (success)
    check._value = graph.aggregate_children_status(check.children)
    assert check._value == Nothing


def test_check_node_update_status_with_failures() -> None:
    """Test CheckNode status aggregation with failed children."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Add mixed success/failure children
    assertion1 = graph.AssertionNode(sp.Symbol("x"), label="Assertion 1")
    assertion1._value = Some(Success(10.0))
    check.add_child(assertion1)

    assertion2 = graph.AssertionNode(sp.Symbol("y"), label="Assertion 2")
    assertion2._value = Some(Failure("Validation failed"))
    check.add_child(assertion2)

    # Aggregate status - should be failure
    check._value = graph.aggregate_children_status(check.children)
    assert isinstance(check._value, Some)
    assert check._value.unwrap() == "Assertion 2: Validation failed"


def test_check_node_update_status_multiple_failures() -> None:
    """Test CheckNode status aggregation with multiple failed children."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Add multiple failures
    assertion1 = graph.AssertionNode(sp.Symbol("x"))
    assertion1._value = Some(Failure("First failure"))
    check.add_child(assertion1)

    assertion2 = graph.AssertionNode(sp.Symbol("y"))
    assertion2._value = Some(Failure("Second failure"))
    check.add_child(assertion2)

    # Aggregate status - should show multiple failures
    check._value = graph.aggregate_children_status(check.children)
    assert isinstance(check._value, Some)
    error_msg = check._value.unwrap()
    assert "Multiple failures:" in error_msg
    assert "First failure" in error_msg
    assert "Second failure" in error_msg


def test_check_node_update_status_preserves_dataset_failure() -> None:
    """Test that aggregation function doesn't override existing dataset mismatch failures."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check", datasets=["required_ds"])
    root.add_child(check)

    # Propagate with wrong dataset - this fails the check
    root.impute_datasets(["different_ds"])

    # Add successful children
    assertion = graph.AssertionNode(sp.Symbol("x"))
    assertion._value = Some(Success(10.0))
    check.add_child(assertion)

    # Verify that the check still has the dataset error
    assert isinstance(check._value, Some)
    assert "requires datasets" in check._value.unwrap()


def test_check_node_update_status_with_pending_children() -> None:
    """Test CheckNode status aggregation with some pending children."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Add mixed evaluated and pending children
    assertion1 = graph.AssertionNode(sp.Symbol("x"))
    assertion1._value = Some(Success(10.0))
    check.add_child(assertion1)

    assertion2 = graph.AssertionNode(sp.Symbol("y"))
    # Leave assertion2 as pending (Nothing)
    check.add_child(assertion2)

    # Aggregate status - should remain Nothing (pending or success)
    check._value = graph.aggregate_children_status(check.children)
    assert check._value == Nothing


def test_check_node_update_status_return_early() -> None:
    """Test that aggregation function doesn't affect pre-existing check failure."""
    check = graph.CheckNode("check", datasets=["required_ds"])

    # Set check to failed state
    check._value = Some("Already failed")

    # Add a successful child
    assertion = graph.AssertionNode(sp.Symbol("x"))
    assertion._value = Some(Success(1.0))
    check.add_child(assertion)

    # Aggregate - this would normally return Nothing for success
    new_value = graph.aggregate_children_status(check.children)
    
    # But the check should keep its original failure
    assert isinstance(check._value, Some)
    assert check._value.unwrap() == "Already failed"
    # The aggregation function returns Nothing (no errors from children)
    assert new_value == Nothing


def test_assertion_node_symbol_error_handling() -> None:
    """Test AssertionNode handling of symbol errors."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Add an assertion with a symbol
    symbol = sp.Symbol("x")
    assertion = graph.AssertionNode(symbol)
    check.add_child(assertion)
    
    # Register the symbol in the symbol table
    ctx.symbol_table.register(SymbolEntry(
        symbol=symbol,
        name="x_metric",
        dataset="ds1",
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(1.0),
    ))
    
    # Propagate datasets - assertion should handle symbol validation
    root.impute_datasets(["ds1"])

    # Assertion should remain in Nothing state (no errors)
    assert isinstance(assertion._value, type(Nothing))


# =============================================================================
# 5. Dataset Propagation Tests
# =============================================================================


def test_dataset_propagation() -> None:
    """Test dataset propagation through the graph."""
    ctx, root = create_test_root("Test")
    check1 = graph.CheckNode("check1", datasets=["ds1"])
    check2 = graph.CheckNode("check2")  # No specific dataset
    root.add_child(check1)
    root.add_child(check2)

    # Add assertions
    assertion1 = graph.AssertionNode(sp.Symbol("x"))
    check1.add_child(assertion1)

    assertion2 = graph.AssertionNode(sp.Symbol("y"))
    check2.add_child(assertion2)

    # Propagate datasets
    root.impute_datasets(["ds1", "ds2"])

    # check1 should keep its dataset requirement
    assert check1.datasets == ["ds1"]
    # check2 should get all datasets
    assert check2.datasets == ["ds1", "ds2"]

    # Children should inherit from their parent check
    assert assertion1.datasets == ["ds1"]
    assert assertion2.datasets == ["ds1", "ds2"]


def test_dataset_validation_errors() -> None:
    """Test dataset validation error cases."""
    ctx, root = create_test_root("Test")

    # Test CheckNode dataset validation error
    check = graph.CheckNode("check1", datasets=["ds_missing"])
    root.add_child(check)
    root.impute_datasets(["ds1", "ds2"])

    # Check should have error value
    assert isinstance(check._value, Some)
    assert "requires datasets ['ds_missing']" in check._value.unwrap()

    # Test AssertionNode dataset validation error
    ctx2, root2 = create_test_root("Test2")
    check2 = graph.CheckNode("check2")
    root2.add_child(check2)

    assertion = graph.AssertionNode(sp.Symbol("x"))
    # Set datasets directly instead of using set_datasource
    assertion.datasets = ["ds_missing"]
    check2.add_child(assertion)

    root2.impute_datasets(["ds1"])
    assert isinstance(assertion._value, Some)
    assert isinstance(assertion._value.unwrap(), Failure)


def test_assertion_node_dataset_validation() -> None:
    """Test assertion node dataset validation during propagation."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Add symbol to symbol table
    symbol_table = ctx.symbol_table
    symbol = sp.Symbol("x")
    entry = SymbolEntry(
        symbol=symbol,
        name="x_metric",
        dataset="ds_missing",
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(1.0),
    )
    symbol_table.register(entry)

    # Add assertion that uses the symbol
    assertion = graph.AssertionNode(symbol)
    check.add_child(assertion)

    # Propagate with different dataset - should trigger validation error through observer
    root.impute_datasets(["ds1"])

    # Assertion should have error due to dataset mismatch
    assert isinstance(assertion._value, Some)
    assert isinstance(assertion._value.unwrap(), Failure)
    assert "requires dataset ds_missing" in assertion._value.unwrap().failure()


def test_impute_datasets_empty_list_raises_error() -> None:
    """Test that impute_datasets raises error when given empty list."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    try:
        root.impute_datasets([])
        assert False, "Should have raised DQXError"
    except DQXError as e:
        assert str(e) == "At least one dataset must be provided!"


def test_check_node_impute_datasets_empty_list_raises_error() -> None:
    """Test that CheckNode.impute_datasets raises error when given empty list."""
    check = graph.CheckNode("check")

    try:
        check.impute_datasets([])
        assert False, "Should have raised DQXError"
    except DQXError as e:
        assert str(e) == "At least one dataset must be provided!"


def test_impute_datasets_with_no_symbol_table_entry() -> None:
    """Test impute_datasets when symbol has no entry in symbol table."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Add assertion with a symbol that doesn't exist in symbol table
    assertion = graph.AssertionNode(sp.Symbol("nonexistent"))
    check.add_child(assertion)

    # This should not raise an error, just skip the non-existent entry
    root.impute_datasets(["dataset1"])

    # Check should still have the dataset
    assert check.datasets == ["dataset1"]
    assert assertion.datasets == ["dataset1"]


def test_assertion_node_validate_datasets_without_symbol_table() -> None:
    """Test assertion node dataset validation when symbol not in symbol table."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)
    
    # Add assertion with symbol that's not in symbol table
    assertion = graph.AssertionNode(sp.Symbol("x"))
    check.add_child(assertion)

    # Propagate datasets - should not raise an error
    root.impute_datasets(["dataset1"])

    # Assertion should have dataset but no errors
    assert assertion.datasets == ["dataset1"]
    assert assertion._value == Nothing


def test_assertion_node_dataset_binding_success() -> None:
    """Test dataset binding when symbol validation succeeds."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Register a symbol that doesn't require a specific dataset
    symbol = sp.Symbol("x")
    entry = SymbolEntry(
        symbol=symbol,
        name="x_metric",
        dataset=None,  # Will bind to any dataset
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(1.0),
    )
    ctx.symbol_table.register(entry)

    # Add assertion with the symbol
    assertion = graph.AssertionNode(symbol)
    check.add_child(assertion)

    # Propagate dataset - should succeed and bind
    root.impute_datasets(["dataset1"])

    # No errors should be recorded
    assert assertion._value == Nothing  # No error
    # Note: dataset binding happens during validate_dataset, but the entry 
    # in our test doesn't require a specific dataset, so it remains None
    assert entry.dataset is None  # Remains None since it accepts any dataset


# =============================================================================
# 6. Evaluation and Computation Tests
# =============================================================================


def test_assertion_node_setters() -> None:
    """Test AssertionNode setter methods."""
    assertion = graph.AssertionNode(actual=sp.Symbol("x"))

    # Test set_label
    assertion.set_label("Test Label")
    assert assertion.label == "Test Label"

    # Test set_severity
    assertion.set_severity("P0")
    assert assertion.severity == "P0"

    # Test set_validator
    validator = SymbolicValidator(name="> 5", fn=lambda x: x > 5)
    assertion.set_validator(validator)
    assert assertion.validator == validator


def test_assertion_node_evaluate_success() -> None:
    """Test successful assertion evaluation."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Add symbols to symbol table
    symbol_table = ctx.symbol_table

    entry_x = SymbolEntry(
        symbol=sp.Symbol("x"),
        name="x_metric",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(10.0),
        state="PROVIDED",
        value=Some(Success(10.0)),
    )
    entry_y = SymbolEntry(
        symbol=sp.Symbol("y"),
        name="y_metric",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(20.0),
        state="PROVIDED",
        value=Some(Success(20.0)),
    )

    symbol_table.register(entry_x)
    symbol_table.register(entry_y)

    # Create assertion
    assertion = graph.AssertionNode(
        actual=sp.Symbol("x") + sp.Symbol("y"), validator=SymbolicValidator(name="> 25", fn=lambda v: v > 25)
    )
    check.add_child(assertion)

    # Evaluate assertion
    result = assertion.evaluate()
    assert isinstance(result, Success)
    assert float(result.unwrap()) == 30.0
    assert float(assertion._value.unwrap().unwrap()) == 30.0


def test_assertion_node_evaluate_validator_failure() -> None:
    """Test assertion evaluation with validator failure."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Add symbol to symbol table
    symbol_table = ctx.symbol_table
    entry = SymbolEntry(
        symbol=sp.Symbol("x"),
        name="x_metric",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(5.0),
        state="PROVIDED",
        value=Some(Success(5.0)),
    )
    symbol_table.register(entry)

    # Create assertion with failing validator
    assertion = graph.AssertionNode(
        actual=sp.Symbol("x"),
        label="Test assertion",
        validator=SymbolicValidator(name="> 10", fn=lambda v: v > 10),
    )
    check.add_child(assertion)

    # Evaluate assertion
    result = assertion.evaluate()
    assert isinstance(result, Failure)
    assert "does not satisfy > 10" in result.failure()
    assert "Test assertion:" in result.failure()


def test_assertion_node_evaluate_missing_symbols() -> None:
    """Test assertion evaluation with missing symbols."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Create assertion without corresponding symbols in symbol table
    assertion = graph.AssertionNode(actual=sp.Symbol("x") + sp.Symbol("y"))
    check.add_child(assertion)

    # Evaluate assertion - should fail due to missing symbols
    result = assertion.evaluate()
    assert isinstance(result, Failure)
    assert "Missing symbols" in result.failure()


def test_assertion_node_evaluate_failed_symbols() -> None:
    """Test assertion evaluation with failed symbol dependencies."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Add symbols to symbol table with different states
    symbol_table = ctx.symbol_table

    entry_x = SymbolEntry(
        symbol=sp.Symbol("x"),
        name="x_metric",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(10.0),
        state="PROVIDED",
        value=Some(Success(10.0)),
    )
    entry_y = SymbolEntry(
        symbol=sp.Symbol("y"),
        name="y_metric",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Failure("Symbol failed"),
        state="ERROR",
        value=Some(Failure("Symbol failed")),
    )

    symbol_table.register(entry_x)
    symbol_table.register(entry_y)

    # Create assertion
    assertion = graph.AssertionNode(actual=sp.Symbol("x") + sp.Symbol("y"))
    check.add_child(assertion)

    # Evaluate assertion - should fail due to failed symbol
    result = assertion.evaluate()
    assert isinstance(result, Failure)
    assert "Symbol dependencies failed" in result.failure()


def test_assertion_node_evaluate_nan_and_infinity() -> None:
    """Test assertion evaluation with NaN and infinity values."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Test NaN
    symbol_table = ctx.symbol_table
    entry_nan = SymbolEntry(
        symbol=sp.Symbol("x"),
        name="nan_metric",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(float("nan")),
        state="PROVIDED",
        value=Some(Success(float("nan"))),
    )
    symbol_table.register(entry_nan)

    assertion_nan = graph.AssertionNode(actual=sp.Symbol("x"))
    check.add_child(assertion_nan)

    result_nan = assertion_nan.evaluate()
    assert isinstance(result_nan, Failure)
    assert "Validating value is NaN" in result_nan.failure()

    # Test infinity
    ctx2, root2 = create_test_root("Test2")
    check2 = graph.CheckNode("check2")
    root2.add_child(check2)

    symbol_table2 = ctx2.symbol_table
    entry_inf = SymbolEntry(
        symbol=sp.Symbol("y"),
        name="inf_metric",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(float("inf")),
        state="PROVIDED",
        value=Some(Success(float("inf"))),
    )
    symbol_table2.register(entry_inf)

    assertion_inf = graph.AssertionNode(actual=sp.Symbol("y"))
    check2.add_child(assertion_inf)

    result_inf = assertion_inf.evaluate()
    assert isinstance(result_inf, Failure)
    assert "Validating value is infinity" in result_inf.failure()


def test_assertion_evaluate_infinity_value() -> None:
    """Test assertion evaluation when the result is infinity."""
    # Create the graph structure
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Register a symbol with a very large value
    x = sp.Symbol("x")

    # Register x with the maximum float value
    entry_x = SymbolEntry(
        symbol=x,
        name="test_symbol_x",
        dataset="test_dataset",
        result_key=ResultKey(date.today(), tags={}),
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(float("inf")),
    )
    ctx.symbol_table.register(entry_x)
    entry_x.mark_success(float("inf"))

    # Create an assertion that will evaluate to infinity
    # Since x is already infinity, the assertion will evaluate to infinity
    assertion = graph.AssertionNode(x)
    check.add_child(assertion)

    # Evaluate the assertion
    result = assertion.evaluate()

    # Should fail with infinity message
    assert isinstance(result, Failure)
    assert result.failure() == "Validating value is infinity"


def test_assertion_node_evaluate_without_root() -> None:
    """Test assertion evaluation without root node."""
    assertion = graph.AssertionNode(actual=sp.Symbol("x"))

    with pytest.raises(RuntimeError, match="AssertionNode is not attached to a CheckNode"):
        assertion.evaluate()


def test_assertion_node_parent_failure() -> None:
    """Test that assertions don't evaluate when parent CheckNode fails."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check", datasets=["required_dataset"])
    root.add_child(check)

    # Add symbol to symbol table
    symbol_table = ctx.symbol_table
    entry = SymbolEntry(
        symbol=sp.Symbol("x"),
        name="x_metric",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(10.0),
        state="PROVIDED",
        value=Some(Success(10.0)),
    )
    symbol_table.register(entry)

    # Add assertion
    assertion = graph.AssertionNode(
        actual=sp.Symbol("x") + 5, validator=SymbolicValidator(name="> 10", fn=lambda v: v > 10)
    )
    check.add_child(assertion)

    # Propagate with wrong dataset - this should fail the check
    root.impute_datasets(["different_dataset"])

    # Evaluate assertion - should fail due to parent failure
    result = assertion.evaluate()
    assert isinstance(result, Failure)
    assert "Parent check failed!" in result.failure()


def test_assertion_node_parent_and_dependency_failures() -> None:
    """Test that parent failures are checked before dependency failures."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check", datasets=["required_dataset"])
    root.add_child(check)

    # Add failing symbol to symbol table
    symbol_table = ctx.symbol_table
    entry = SymbolEntry(
        symbol=sp.Symbol("x"),
        name="x_metric",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Failure("Symbol error"),
        state="ERROR",
        value=Some(Failure("Symbol error")),
    )
    symbol_table.register(entry)

    # Add assertion with missing symbol y
    assertion = graph.AssertionNode(
        actual=sp.Symbol("x") + sp.Symbol("y"),  # y is missing
    )
    check.add_child(assertion)

    # Propagate with wrong dataset - this should fail the check
    root.impute_datasets(["different_dataset"])

    # Evaluate assertion - should fail due to parent failure, not dependency issues
    result = assertion.evaluate()
    assert isinstance(result, Failure)
    assert "Parent check failed!" in result.failure()
    # Should not mention symbol dependencies or missing symbols
    assert "Symbol dependencies failed" not in result.failure()
    assert "Missing symbols" not in result.failure()


def test_assertion_node_find_parent_check() -> None:
    """Test the _find_parent_check helper method."""
    ctx, root = create_test_root("Test")
    check1 = graph.CheckNode("check1")
    check2 = graph.CheckNode("check2")
    root.add_child(check1)
    root.add_child(check2)

    assertion1 = graph.AssertionNode(sp.Symbol("x"))
    assertion2 = graph.AssertionNode(sp.Symbol("y"))
    assertion3 = graph.AssertionNode(sp.Symbol("z"))

    check1.add_child(assertion1)
    check2.add_child(assertion2)
    # assertion3 is not added to any check

    # Test finding parent checks
    assert assertion1._find_parent_check() == check1
    assert assertion2._find_parent_check() == check2
    
    # assertion3 has no parent, should raise RuntimeError
    with pytest.raises(RuntimeError, match="AssertionNode is not attached to a CheckNode"):
        assertion3._find_parent_check()

    # Test with no root
    assertion4 = graph.AssertionNode(sp.Symbol("w"))
    with pytest.raises(RuntimeError, match="AssertionNode is not attached to a CheckNode"):
        assertion4._find_parent_check()


def test_assertion_node_find_root_error() -> None:
    """Test _find_root method error case."""
    assertion = graph.AssertionNode(actual=sp.Symbol("x"))

    with pytest.raises(RuntimeError, match="Node is not attached to a graph"):
        assertion.root


def test_assertion_node_find_root_already_set() -> None:
    """Test _find_root when root is already set."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)
    
    assertion = graph.AssertionNode(sp.Symbol("x"))
    check.add_child(assertion)

    # Call _find_root - should return the root
    found_root = assertion.root
    assert found_root is root


def test_assertion_node_mark_as_failure() -> None:
    """Test marking assertion as failure."""
    assertion = graph.AssertionNode(actual=sp.Symbol("x"))

    assertion.mark_as_failure("Test failure message")

    assert isinstance(assertion._value, Some)
    assert isinstance(assertion._value.unwrap(), Failure)
    assert assertion._value.unwrap().failure() == "Test failure message"


def test_assertion_node_evaluate_no_validator() -> None:
    """Test assertion evaluation without validator (just computes value)."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Add symbol to symbol table
    symbol_table = ctx.symbol_table
    entry = SymbolEntry(
        symbol=sp.Symbol("x"),
        name="x_metric",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(10.0),
        state="PROVIDED",
        value=Some(Success(10.0)),
    )
    symbol_table.register(entry)

    # Create assertion without validator
    assertion = graph.AssertionNode(actual=sp.Symbol("x") * 2)
    check.add_child(assertion)

    # Evaluate assertion
    result = assertion.evaluate()
    assert isinstance(result, Success)
    assert float(result.unwrap()) == 20.0


def test_assertion_evaluate_with_no_expression_symbols() -> None:
    """Test evaluate with a constant expression (no symbols)."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)
    
    # Create assertion with constant expression
    assertion = graph.AssertionNode(sp.Integer(5))
    check.add_child(assertion)

    result = assertion.evaluate()
    assert isinstance(result, Success)
    assert float(result.unwrap()) == 5.0


# =============================================================================
# 7. Error Handling Tests
# =============================================================================


def test_assertion_node_evaluate_exception() -> None:
    """Test assertion evaluation with exception."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Create a symbol that causes division by zero
    symbol_table = ctx.symbol_table
    entry = SymbolEntry(
        symbol=sp.Symbol("x"),
        name="x_metric",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(0.0),
        state="PROVIDED",
        value=Some(Success(0.0)),
    )
    symbol_table.register(entry)

    # Create assertion with division by zero
    assertion = graph.AssertionNode(actual=sp.Integer(1) / sp.Symbol("x"))
    check.add_child(assertion)

    # Evaluate assertion - should catch exception
    result = assertion.evaluate()
    assert isinstance(result, Failure)


# =============================================================================
# 8. Observer Pattern Tests
# =============================================================================


def test_symbol_error_propagates_to_assertion() -> None:
    """Test that symbol errors propagate to assertion nodes via observer pattern."""
    # Create a symbol table and register a symbol
    ctx, root = create_test_root("test_root")
    symbol_table = ctx.symbol_table
    symbol = sp.Symbol("test_metric")
    entry = SymbolEntry(
        symbol=symbol,
        name="test_metric",
        dataset="dataset1",  # This dataset is required
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(1.0),
    )
    symbol_table.register(entry)

    # Create a check and assertion node
    check = graph.CheckNode("test_check")
    root.add_child(check)
    
    assertion = graph.AssertionNode(symbol)
    check.add_child(assertion)

    # Propagate with a different dataset - should trigger error notification
    root.impute_datasets(["dataset2"])

    # Assertion should receive the error
    assert isinstance(assertion._value, Some)
    result = assertion._value.unwrap()
    assert isinstance(result, Failure)
    assert "requires dataset dataset1" in result.failure()


def test_symbol_success_clears_errors() -> None:
    """Test that symbol success notifications clear previous errors."""
    # Create a symbol table and register a symbol
    ctx, root = create_test_root("test_root")
    symbol_table = ctx.symbol_table
    symbol = sp.Symbol("test_metric")
    entry = SymbolEntry(
        symbol=symbol,
        name="test_metric",
        dataset=None,  # No specific dataset required
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(1.0),
    )
    symbol_table.register(entry)

    # Create check and assertion nodes
    check = graph.CheckNode("test_check")
    root.add_child(check)
    
    assertion = graph.AssertionNode(symbol)
    check.add_child(assertion)

    # First, trigger an error
    entry.mark_error("Test error")
    # This should propagate to assertion via observer
    
    # Then mark as success
    entry.mark_success(1.0)
    # The error should be cleared
    
    # Verify by evaluating the assertion
    result = assertion.evaluate()
    assert isinstance(result, Success)
    assert float(result.unwrap()) == 1.0


def test_multiple_assertions_observe_same_symbol() -> None:
    """Test that multiple assertions can observe the same symbol."""
    ctx, root = create_test_root("test_root")
    symbol_table = ctx.symbol_table
    symbol = sp.Symbol("shared_metric")
    entry = SymbolEntry(
        symbol=symbol,
        name="shared_metric",
        dataset="dataset1",
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(1.0),
    )
    symbol_table.register(entry)

    # Create multiple assertions observing the same symbol
    check1 = graph.CheckNode("check1")
    root.add_child(check1)
    assertion1 = graph.AssertionNode(symbol)
    check1.add_child(assertion1)

    check2 = graph.CheckNode("check2")
    root.add_child(check2)
    assertion2 = graph.AssertionNode(symbol)
    check2.add_child(assertion2)

    # Trigger an error
    entry.mark_error("Shared error")

    # Both assertions should be affected
    result1 = assertion1.evaluate()
    result2 = assertion2.evaluate()
    
    assert isinstance(result1, Failure)
    assert isinstance(result2, Failure)
    assert "Symbol dependencies failed" in result1.failure()
    assert "Symbol dependencies failed" in result2.failure()


def test_check_failure_affects_assertions() -> None:
    """Test that check failures affect child assertions."""
    ctx, root = create_test_root("test_root")
    
    # Create a check with dataset requirements that will fail
    check = graph.CheckNode("test_check", datasets=["required_ds"])
    root.add_child(check)

    # Add an assertion
    assertion = graph.AssertionNode(actual=sp.Symbol("x") + 1)
    check.add_child(assertion)

    # Propagate wrong dataset to fail the check
    root.impute_datasets(["wrong_ds"])

    # Evaluate assertion - should fail due to parent check failure
    result = assertion.evaluate()
    assert isinstance(result, Failure)
    assert "Parent check failed!" in result.failure()


def test_assertion_node_on_symbol_ready() -> None:
    """Test the on_symbol_ready method."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)
    
    symbol = sp.Symbol("x")
    assertion = graph.AssertionNode(symbol)
    check.add_child(assertion)

    # Register symbol in symbol table
    entry = SymbolEntry(
        symbol=symbol,
        name="x",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(1.0),
    )
    ctx.symbol_table.register(entry)
    
    # Call on_symbol_ready - should update parent check status
    assertion.on_symbol_ready(symbol)

    # Verify the assertion is still in pending state
    assert assertion._value == Nothing


def test_assertion_node_on_symbol_success() -> None:
    """Test on_symbol_success notification."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)
    
    symbol = sp.Symbol("x")
    assertion = graph.AssertionNode(symbol)
    check.add_child(assertion)

    # Register and setup symbol
    entry = SymbolEntry(
        symbol=symbol,
        name="x",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(10.0),
    )
    ctx.symbol_table.register(entry)
    
    # Call on_symbol_success
    assertion.on_symbol_success(symbol, 10.0)

    # The on_symbol_success just clears errors and updates parent
    # But doesn't directly affect evaluation - we need to mark the entry as success
    entry.mark_success(10.0)
    
    # Now verify by evaluating
    result = assertion.evaluate()
    assert isinstance(result, Success)
    assert float(result.unwrap()) == 10.0


def test_assertion_node_symbol_error_then_success() -> None:
    """Test symbol error followed by success."""
    ctx, root = create_test_root("Test")
    check = graph.CheckNode("check")
    root.add_child(check)

    # Add an assertion
    symbol = sp.Symbol("x")
    assertion = graph.AssertionNode(symbol + 1)
    check.add_child(assertion)

    # Register symbol
    entry = SymbolEntry(
        symbol=symbol,
        name="x",
        dataset=None,
        result_key=None,
        metric_spec=None,
        ops=[],
        retrieval_fn=lambda k: Success(10.0),
    )
    ctx.symbol_table.register(entry)

    # First trigger an error via the entry
    entry.mark_error("Test error")
    
    # Verify error state
    result_error = assertion.evaluate()
    assert isinstance(result_error, Failure)
    assert "Symbol dependencies failed" in result_error.failure()
    
    # Then mark success
    entry.mark_success(10.0)
    
    # Verify by evaluating
    result = assertion.evaluate()
    assert isinstance(result, Success)
    assert float(result.unwrap()) == 11.0  # 10 + 1


# =============================================================================
# 9. Minimal Coverage Tests for Display Methods
# =============================================================================


def test_node_format_display_methods_exist() -> None:
    """Test that all node types have format_display methods for coverage."""
    # RootNode
    ctx, root = create_test_root("Test Suite")
    assert hasattr(root, "format_display")
    root.format_display()  # Call to cover the method

    # CheckNode
    check = graph.CheckNode("check1", label="Check One", datasets=["ds1"])
    check.format_display()

    # AssertionNode with different states
    assertion = graph.AssertionNode(actual=sp.Symbol("x"))
    assertion.format_display()

    # AssertionNode with validator
    validator = SymbolicValidator(name="> 10", fn=lambda x: x > 10)
    assertion_with_validator = graph.AssertionNode(actual=sp.Symbol("x"), validator=validator)
    assertion_with_validator.format_display()


def test_root_node_inspect_method() -> None:
    """Test RootNode inspect method for coverage."""
    ctx, root = create_test_root("Test Suite")
    check = graph.CheckNode("check1")
    root.add_child(check)

    # Call inspect to cover the method
    display = GraphDisplay()
    tree = display.inspect_tree(root)
    assert tree is not None  # Just verify it returns something
